<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java-SE学习笔记6</title>
    <link href="/2025/08/05/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06/"/>
    <url>/2025/08/05/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06/</url>
    
    <content type="html"><![CDATA[<h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><blockquote><p>一种未知的数据类型，当我们不知道使用什么数据类型，就可以使用泛型</p><p>泛型也可以看做是一个变量，用来接受数据类型</p><p>E e:Element 元素         T t:Type 类型</p><p>创建集合对象，不使用泛型：默认类型是Object类型，可存储任意类型的数据；不安全，会引发异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<span class="hljs-comment">//不写尖括号就是默认Object类型</span><br></code></pre></td></tr></table></figure><p><img src="E:\blog\source\img\cr\Java-SE\45.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class <span class="hljs-number">111</span>&lt;E&gt;&#123;&#125;<span class="hljs-comment">//泛型类</span><br><span class="hljs-keyword">public</span> &lt;M&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(M m)</span>&#123;&#125;<span class="hljs-comment">//泛型方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(S s)</span>&#123;&#125;<span class="hljs-comment">//泛型静态方法</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GenericInter</span>&lt;I&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(I i)</span>;<span class="hljs-comment">//泛型接口的实现类有两种实现方法</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenericInter</span>&lt;String&gt;<span class="hljs-comment">//一种是在类的实现时就定义数据类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterImp2</span>&lt;I&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenericInter</span>&lt;I&gt;<span class="hljs-comment">//一种是在类的实现时不定义数据类型，使用时才定义数据类型</span><br></code></pre></td></tr></table></figure><h5 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h5><p>不知道使用什么类型来接收时，可以使用？，？代表未知通配符</p><p>只能接受数据，不能往集合中存储数据(只能作为参数传递，不能在创建数据时使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(ArrayList&lt;?&gt; array)</span>&#123;<br>        Iterator&lt;?&gt; itrt = array.iterator();<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="通配符高级使用：受限泛型"><a href="#通配符高级使用：受限泛型" class="headerlink" title="通配符高级使用：受限泛型"></a>通配符高级使用：受限泛型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称 &lt;? extends 类&gt; 对象名称<span class="hljs-comment">//泛型上限：只能接受该类型及其子类</span><br>类型名称 &lt;? <span class="hljs-built_in">super</span> 类&gt; 对象名称<span class="hljs-comment">//泛型下限：只能接受该类型及其父类</span><br></code></pre></td></tr></table></figure><p><img src="E:\blog\source\img\cr\Java-SE\46.png"></p><p>会看就行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.shuffle(poker);<span class="hljs-comment">//collections混合排序方法</span><br></code></pre></td></tr></table></figure><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><blockquote><p>数据存储常用结构：栈、队列、数组、链表和红黑树</p><h5 id="栈：先进后出"><a href="#栈：先进后出" class="headerlink" title="栈：先进后出"></a>栈：先进后出</h5><h5 id="队列：先进先出"><a href="#队列：先进先出" class="headerlink" title="队列：先进先出"></a>队列：先进先出</h5><p><img src="E:\blog\source\img\cr\Java-SE\47.png"></p><h5 id="数组：查询快，增删慢"><a href="#数组：查询快，增删慢" class="headerlink" title="数组：查询快，增删慢"></a>数组：查询快，增删慢</h5><p><img src="E:\blog\source\img\cr\Java-SE\48.png"></p><h5 id="链表：查询慢，增删快"><a href="#链表：查询慢，增删快" class="headerlink" title="链表：查询慢，增删快"></a>链表：查询慢，增删快</h5><p><img src="E:\blog\source\img\cr\Java-SE\49.png"></p><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p><img src="E:\blog\source\img\cr\Java-SE\50.png"></p></blockquote><h5 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h5><blockquote><p><img src="E:\blog\source\img\cr\Java-SE\51.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>实现类：ArrayList集合、LinkedList集合</p><p>ArrayList集合数据存储的结构是数组结构，结合数组的特点，不应该用于增删操作多的地方</p><p>LinkedList是链表结构，使用LinkedList集合特有的方法，不能使用多态</p><p><img src="E:\blog\source\img\cr\Java-SE\52.png"></p><p>还有addLast()等效于add()</p><p>ll.clear()清空</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记5</title>
    <link href="/2025/08/04/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/"/>
    <url>/2025/08/04/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/</url>
    
    <content type="html"><![CDATA[<h5 id="Object类-java-lang-object"><a href="#Object类-java-lang-object" class="headerlink" title="Object类(java.lang.object)"></a>Object类(java.lang.object)</h5><blockquote><p>所有类的父类，所有类都可以使用Object类中的方法</p><p>都可以code+generate,自动生成@Override</p><p><strong>toString</strong></p><p>直接打印对象的名字，就是调用toString方法</p><p>scanner和ArrayList重写了toString方法，所以打印出来的东西不是地址值</p><p><strong>equals</strong></p><p>基本类型不能比较，引用类型比较地址值(a1.equals(a2)),返回布尔值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getClass() != o.getClass()<span class="hljs-comment">//判断是否与当前类的类型相同</span><br></code></pre></td></tr></table></figure><p>Objects类的equals方法：在对两个对象进行比较时，防止空指针异常</p><p>(a1.equals(a2) 当a1为null值时，就会发生空指针异常，NullPointerException)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object a, Object b)</span> &#123;<br>        <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-literal">null</span> &amp;&amp; a.equals(b));<br>    &#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="日期时间类-java-util-date"><a href="#日期时间类-java-util-date" class="headerlink" title="日期时间类(java.util.date)"></a>日期时间类(java.util.date)</h5><blockquote><p><strong>Date</strong></p><p>表示特定的瞬间，精确到毫秒</p><p>时间原点(0毫秒)：1970年1月1日 00:00:00(英国格林威治)(中国是东八区，要加八个小时)</p><p><strong>System.currentTimeMills()</strong>：获取当前时间(毫秒)(long类型)</p><p>一天 &#x3D; 24<em>60</em>60 &#x3D; 86400秒 * 1000 &#x3D; 86400000毫秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<span class="hljs-comment">//以下时间函数的使用需要创建对象</span><br></code></pre></td></tr></table></figure><p><strong>Date()</strong>:获取当前系统的日期和时间</p><p><strong>Date(long date)</strong>:传递毫秒值，把毫秒值转换为Date日期</p><p><strong>long getTime()</strong>:把日期转换为毫秒值(相当于System.currentTimeMills()方法)，返回自时间原点以来的毫秒值</p><p><strong>DateFormat(java.text.DateFormat)</strong>(抽象类)(直接已知子类：SimpleDateFormat)</p><blockquote><p>方法format：把日期格式转换为文本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd,HH:mm:ss&quot;</span>);<br></code></pre></td></tr></table></figure><p>方法parse:把文本解析为日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Date <span class="hljs-title function_">parse</span><span class="hljs-params">(String source)</span> <span class="hljs-keyword">throws</span> ParseException<br></code></pre></td></tr></table></figure><p>如果字符串和构造方法的博士不一样，程序就会抛出解析异常，要么throws继续抛出，要么try catch自己处理</p><p>红线异常用alt+enter抛出异常</p></blockquote><h5 id="Calendar-java-util-Calendar-抽象类"><a href="#Calendar-java-util-Calendar-抽象类" class="headerlink" title="Calendar(java.util.Calendar)(抽象类)"></a>Calendar(java.util.Calendar)(抽象类)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar <span class="hljs-number">111</span> = Calendar.getInstance();<br></code></pre></td></tr></table></figure><p><img src="/39.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> c.get(Calendar.MONTH);<br></code></pre></td></tr></table></figure><p>西方的月份是0-11月</p><p>set的一个重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">c.set(<span class="hljs-number">2019</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>);<span class="hljs-comment">//同时设置</span><br></code></pre></td></tr></table></figure><p>add方法的第二个参数，如果是正数就是加，负数就是减</p></blockquote><h5 id="System类-java-lang-System"><a href="#System类-java-lang-System" class="headerlink" title="System类(java.lang.System)"></a>System类(java.lang.System)</h5><blockquote><p><strong>System.currentTimeMills()</strong>：获取当前时间(毫秒)(long类型)</p><p>可以测试程序的效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.arraycopy(src, srcPos, dest, destPos, length);<br></code></pre></td></tr></table></figure><p>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。 </p></blockquote><h5 id="StringBuilder类-字符串缓冲区"><a href="#StringBuilder类-字符串缓冲区" class="headerlink" title="StringBuilder类(字符串缓冲区)"></a>StringBuilder类(字符串缓冲区)</h5><blockquote><p>字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</p><p><img src="/40.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">111</span>);<span class="hljs-comment">//无数据或者初始化字符串</span><br>sb.append(<span class="hljs-number">111</span>);<span class="hljs-comment">//可以添加任意内容</span><br>sb.toString(<span class="hljs-number">111</span>);<span class="hljs-comment">//StringBuilder转换为字符串，反转则是new StringBuilder(111);</span><br></code></pre></td></tr></table></figure><p>链式编程，可以一直.append()下去</p></blockquote><h5 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h5><blockquote><p><img src="/41.png"></p><p>111.intValue();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//自动装箱</span><br>i = i + <span class="hljs-number">2</span>;<span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure><p>ArrayList的.add()函数和.get()函数，其实就是自动装箱和自动拆箱</p><p><img src="/42.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.toString(<span class="hljs-number">111</span>);String.valueOf(<span class="hljs-number">111</span>);<br>Integer.parseInt(<span class="hljs-number">111</span>);<br></code></pre></td></tr></table></figure></blockquote><h5 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h5><blockquote><p>数组长度固定，集合长度可变</p><p>数组存储同一类型袁术，存储基本数据类型；集合存储对象，对象类型不一致</p><p><img src="/43.png"></p></blockquote><h5 id="Collection常用功能"><a href="#Collection常用功能" class="headerlink" title="Collection常用功能"></a>Collection常用功能</h5><blockquote><p><img src="/44.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Object[] strArray = coll.toArray();<br></code></pre></td></tr></table></figure><p>remove函数只移除找到的第一个对象</p></blockquote><h5 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h5><blockquote><p><strong>迭代</strong>：即Collection集合元素的通用获取方式。在区元素之前先判断集合中有没有元素，如果有，取元素，继续判断，继续取元素，一直到把集合中所有的元素全部取出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;Integer&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Iterator&lt;Integer&gt; itrt = coll.iterator();<br>        <span class="hljs-keyword">while</span>(itrt.hasNext())&#123;<br>            System.out.print(itrt.next()+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><p>创建iterator的实现类对象时，会把指针指向集合的-1索引</p><p>hasnext()判断集合有没有下一个元素，next()做了两件事情：1.取出下一个元素  2.把指针向后移动一位</p></blockquote><h5 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h5><blockquote><p>也称for each循环，内部原理是Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(集合/数组的数据类型 变量名：集合名/数组名)&#123;<br>sout(变量名);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(String i:coll)&#123;<br>            System.out.println(i);<br>        &#125;<br></code></pre></td></tr></table></figure><p>新for循环必须有被遍历的目标，目标只能是Collection或者数组</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记4</title>
    <link href="/2025/08/02/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <url>/2025/08/02/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<h5 id="多态-对象的多态性"><a href="#多态-对象的多态性" class="headerlink" title="多态(对象的多态性)"></a>多态(对象的多态性)</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类名称 对象名 = <span class="hljs-keyword">new</span> 子类名称();<br>接口名称 对象名 = <span class="hljs-keyword">new</span> 实现类名称();<br></code></pre></td></tr></table></figure><p>当父类和子类有相同方法时，<strong>看new的是谁实现谁的方法</strong>，这里new的是子类，所以实现子类的方法</p><p>只有方法能被<strong>覆盖重写，成员变量不行</strong>，所以使用对象名访问成员变量时，看左边是谁优先用谁，没有则向上找</p><p>间接通过成员方法访问成员变量，方法属于谁优先用谁，没有则向上找</p><p>成员变量：编译看左边，运行还看左边</p><p>成员方法：编译看左边，运行看右边</p><p><img src="/img/cr/Java-SE/35.png"></p><p>使用多态的方法，就可以统一右边的语句，看起来规整</p><p><strong>对象的向上转型</strong>(父类名称 对象名 &#x3D; new 子类名称();)</p><p>子类就只能使用父类中已经定义的方法，限制子类动作(一定安全：小范围-&gt;大范围)</p><p><strong>对象的向下转型</strong>(子类名称 新对象名 &#x3D; (子类名称) 原对象名;)</p><p>必须本来是这个子类，才能还原为这个子类(java.lang.ClassCastException类转换异常)</p><p>(对象名 instanceof 子类名称)返回一个boolean值，判断对象是不是该类型的实例</p><p>使用接口作为方法参数，但是传进去的是该接口的实现类时，会自动向上转型为接口</p></blockquote><h5 id="final-最终的，不可该变的"><a href="#final-最终的，不可该变的" class="headerlink" title="final(最终的，不可该变的)"></a>final(最终的，不可该变的)</h5><blockquote><p>类(不能有任何的子类，所有成员方法都无法被覆盖重写)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class <span class="hljs-number">111</span>&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法(不能被覆盖重写)(类与方法中都不能将abstract和final同时使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-number">111</span>()&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量(一次赋值，终身不变)(基本类型数据不变，引用类型地址值不变)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> 数据类型 <span class="hljs-number">111</span> = <span class="hljs-number">111</span>;<br></code></pre></td></tr></table></figure><p>成员变量(必须手动赋值，因为不赋值的话成员变量会自动赋空值)(构造赋值和直接复制二选一)</p><p>(必须保证类当中所有重载的构造方法，都最终回嘴final的成员变量进行赋值)</p></blockquote><h5 id="权限修饰符：-public-protected-default-留空的意思-private"><a href="#权限修饰符：-public-protected-default-留空的意思-private" class="headerlink" title="权限修饰符：           public&gt;protected&gt;(default)(留空的意思)&gt;private"></a>权限修饰符：           public&gt;protected&gt;(default)(留空的意思)&gt;private</h5><blockquote><p>同一个类：             Yes           Yes             Yes                                   Yes</p><p>同一个包:                Yes           Yes             Yes                                   No</p><p>不同包子类：          Yes           Yes             No                                   No</p><p>不同包非子类：      Yes           No             No                                   No</p></blockquote><h5 id="内部类-成员内部类和局部内部类-包含匿名内部类"><a href="#内部类-成员内部类和局部内部类-包含匿名内部类" class="headerlink" title="内部类(成员内部类和局部内部类(包含匿名内部类))"></a>内部类(成员内部类和局部内部类(包含匿名内部类))</h5><blockquote><h5 id="成员内部类-在方法外面"><a href="#成员内部类-在方法外面" class="headerlink" title="成员内部类(在方法外面)"></a>成员内部类(在方法外面)</h5></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 Class 外部类名称&#123;<br>修饰符 class 内部类名称&#123;<br><span class="hljs-number">111</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内用外，随意访问；外用内，需要内部类对象</p><p>使用方式：1.通过外部类对象，调用外部类的方法，在里面间接使用内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2.</span>外部类名称.内部类名称 对象名 = <span class="hljs-keyword">new</span> 外部类名称().new 内部类名称();<br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/36.png"></p><h5 id="局部内部类-在方法里面"><a href="#局部内部类-在方法里面" class="headerlink" title="局部内部类(在方法里面)"></a>局部内部类(在方法里面)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 Class 外部类名称&#123;<br> 修饰符 返回值类型 外部类方法名称(参数列表)&#123;<br>     修饰符 class 内部类名称&#123;<br><span class="hljs-number">111</span><br>&#125;<br>     内部类名称 <span class="hljs-number">111</span> = <span class="hljs-keyword">new</span> 内部类名称();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/37.png"></p><p>局部内部类，如果希望访问所在方法的局部变量，这个局部变量必须是<strong>有效final</strong>的(不能改变)</p><p>(从java8+开始，只要局部变量事实不变，那么final关键字可以省略)</p><p>原因：1.new出来的对象在<strong>堆内存</strong>中，垃圾回收才会消失</p><p>​   2.局部变量跟着方法走，而方法在<strong>栈内存</strong>中，方法运行入栈，运行结束出栈，局部变量就      会立即消失</p><h5 id="匿名内部类-局部内部类中的"><a href="#匿名内部类-局部内部类中的" class="headerlink" title="匿名内部类(局部内部类中的)"></a><strong>匿名内部类</strong>(局部内部类中的)</h5><p>如果接口的实现类(或者父类的子类)只需要使用唯一的一次，就可以忽略该类的定义，使用匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">接口名称 对象名 = <span class="hljs-keyword">new</span> 接口名称()&#123;<br> <span class="hljs-comment">//覆盖重写所有抽象方法</span><br>&#125;;<span class="hljs-comment">//匿名内部类</span><br><span class="hljs-keyword">new</span> 接口名称()&#123;<br> 修饰符 返回值类型 <span class="hljs-number">111</span>()&#123;<br>     <span class="hljs-number">111</span><br> &#125;<br>&#125;<span class="hljs-number">.111</span>();<span class="hljs-comment">//匿名内部类，也是匿名对象</span><br></code></pre></td></tr></table></figure><p><strong>注意不要丢了分号</strong></p><p><img src="/img/cr/Java-SE/38.png"></p></blockquote><h5 id="成员变量补充"><a href="#成员变量补充" class="headerlink" title="成员变量补充"></a>成员变量补充</h5><blockquote><p>成员变量不仅可以为数据类型，还可为类class，接口也可以为成员变量的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> 数据类型 数据名称;<br><span class="hljs-keyword">public</span> class 类名称&#123;&#125;<br>类名称 对象名称 = <span class="hljs-keyword">new</span> 类名称();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> 数据类型 方法名称();<br><span class="hljs-keyword">public</span> class 类名称 implements 接口名称&#123;<span class="hljs-meta">@Override</span>&#125;<br>类名称 对象名称 = <span class="hljs-keyword">new</span> 类名称();<br></code></pre></td></tr></table></figure><p>使用单独定义的实现类&#x2F;使用匿名内部类&#x2F;同时使用匿名内部类和匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">对象名称.set数据名称(<span class="hljs-keyword">new</span> 类名称());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">类名称 对象名称 = <span class="hljs-keyword">new</span> 类名称()&#123;<span class="hljs-meta">@Override</span>&#125;&#125;;<br>对象名称.set数据名称(<span class="hljs-number">111</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">对象名称.set数据名称(<span class="hljs-keyword">new</span> 类名称()&#123;<span class="hljs-meta">@Override</span>&#125;);<br></code></pre></td></tr></table></figure><p>接口可以作为方法的参数和返回值</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记3</title>
    <link href="/2025/08/01/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <url>/2025/08/01/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h5 id="Arrays相关函数"><a href="#Arrays相关函数" class="headerlink" title="Arrays相关函数"></a>Arrays相关函数</h5><blockquote><p>toString:将参数数组变成字符串</p><p>sort:按照升序排列数组元素(直接在原数组上排序)</p><p>(如果是自定义的类，需要有Comparable或者Comparator接口的支持)</p></blockquote><h5 id="Math相关函数"><a href="#Math相关函数" class="headerlink" title="Math相关函数"></a>Math相关函数</h5><blockquote><p><img src="/img/cr/Java-SE/30.png"></p><p>四舍五入不带小数点</p><p>Math.PI</p></blockquote><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><blockquote><p>继承主要解决的问题是：共性抽取</p><p>父类也可以叫基类、超类；子类也可以叫派生类</p><p>有子用子，无子找父</p><p>子类对象  使用父类方法中  调用的数据是父类的(在父类中定义的)</p><p><img src="/img/cr/Java-SE/31.png"></p><p>重写(Override):方法名称和参数列表都一样，重载参数列表不一样(@Override)</p><p>返回值范围：子类方法【小于等于】父类方法</p><p>权限：子类方法【大于等于】父类方法(public&gt;protected&gt;(default)(留空的意思)&gt;private)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-number">111</span>()&#123;<br><span class="hljs-built_in">super</span><span class="hljs-number">.111</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>子类构造方法中有一个默认隐含的“super()；”调用，所有一定是先执行父类构造，后执行子类构造，且只能有一个super()；调用父类构造方法，且必须是构造方法第一句</p><p>可以通过super关键字  从子类  构造  父类的重载构造</p><p><img src="/img/cr/Java-SE/32.png"></p><p><img src="/img/cr/Java-SE/33.png"></p><p><img src="/img/cr/Java-SE/34.png"></p><p>单继承、多级继承、多继承</p></blockquote><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><blockquote><p>如果父类中的方法不确定如何实现，就是一个抽象方法</p><p>抽象方法所在的类必须是抽象类，但抽象类中不一定有抽象方法，这种抽象类也不能直接创建对象，在一些特殊场景下有用途</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> class <span class="hljs-number">111</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-number">111</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>不能直接创建抽象类对象，抽象类必须由子类继承后，<strong>将所有抽象方法覆盖重写</strong>(去掉abstarct关键词实现)，如果抽象方法没有全部覆盖重写成非抽象方法，那么这个子类也是抽象类</p><p>抽象父类可以有构造方法，但那是在  创建子类对象时  调用子类构造方法中  的super();时  使用的</p></blockquote><h5 id="发红包问题的分析"><a href="#发红包问题的分析" class="headerlink" title="发红包问题的分析"></a>发红包问题的分析</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">发红包的逻辑<br>返回值  ArrayList&lt;Double&gt;<br>名称  send<br>参数列表  ArrayList&lt;Double&gt;<br><br>收红包的逻辑<br>返回值  ArrayList&lt;Double&gt;<br>名称  recieve<br>参数列表  ArrayList&lt;Double&gt;<br><br>用户类：姓名，余额-&gt;群主类：姓名，余额，send;群员类：姓名，余额，id,n(与idCounter类似),recieve<br></code></pre></td></tr></table></figure></blockquote><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><blockquote><p>接口就是多个类的公共规范</p><p>接口是一种引用数据类型，最重要的就是其中的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface 接口名称&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接口的字节码文件仍然是.class文件</p><p>java7:1.常量  2.抽象方法  java8:3.默认方法  4.静态方法  java9：5.私有方法</p><h5 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h5><p>修饰符必须是两个固定的关键词：public abstract(这两个都可以选择性的省略)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-number">111</span>();<br></code></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>1.接口不能直接使用，必须有一个实现类来实现该接口，创建实现类的对象进行使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 实现类名称 implements 接口名称&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.接口的实现类必须覆盖重写接口中所有的抽象方法，如果实现类没有完全覆盖接口中的抽象方法，这个实现类必须是抽象类</p><p>3.接口不能有静态代码块或者构造方法</p><p>4.一个类的父类是唯一的，但是一个类可以同时实现多个接口</p><p>5.如果接口中有重复的抽象方法，只用覆盖重写一次就行；有重复的默认方法，必须对冲突的默认方法进行覆盖重写</p><p>6.直接父类和接口中的方法产生冲突，优先只 使用父类的方法</p><p>7.类与类单继承，类与接口多实现，接口与接口多继承</p><p><strong>默认方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> 返回值类型 方法名称(参数列表)&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认方法库通过接口实现类对象直接调用，也可以被接口实现类进行覆盖重写</p><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名称(参数列表)&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不能通过接口实现类的对象  来调用接口当中的静态方法，应该使用接口名称调用(不用创建类和对象)</p><h5 id="私有方法-分为默认和静态两种，静态私有方法-解决-多个静态方法之间重复代码-的问题"><a href="#私有方法-分为默认和静态两种，静态私有方法-解决-多个静态方法之间重复代码-的问题" class="headerlink" title="私有方法(分为默认和静态两种，静态私有方法  解决  多个静态方法之间重复代码  的问题)"></a>私有方法(分为默认和静态两种，静态私有方法  解决  多个静态方法之间重复代码  的问题)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> (<span class="hljs-keyword">static</span>) 返回值类型 方法名称(参数列表)&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>必须使用public static final三个关键词修饰，可以省略，但是意思不变</p><p>一旦使用final关键字，说明不可改变，也因此该常量必须进行赋值(定义名称规范：INT_NUM)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记2</title>
    <link href="/2025/07/30/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2025/07/30/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h5 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h5><blockquote><p>面向对象三大特征：封装、继承、多态</p><p>方法就是一种封装；private关键字也是一种封装</p><p>间接访问private成员变量，就是定义一对setter&#x2F;getter方法</p><p>boolean类型的getter方法不能写get111，要写is111</p><p>this.成员变量名，访问本类中的成员变量</p><p>构造方法：</p><p><img src="/img/cr/Java-SE/22.png"></p><p>即使全参构造方法中已经存在this.111 &#x3D; 111;依然需要setter方法，方便后续修改</p><p>标准的类（Java bean）：所有成员变量都用的private修饰、无参方法、全参方法、每个成员变量都要用getter&#x2F;setter修饰</p><p>构造方法、getter&#x2F;setter自动补全：Code-&gt;Generate</p></blockquote><h5 id="Scanner、匿名对象、Random、ArrayList"><a href="#Scanner、匿名对象、Random、ArrayList" class="headerlink" title="Scanner、匿名对象、Random、ArrayList"></a>Scanner、匿名对象、Random、ArrayList</h5><blockquote><p>合理使用api文档，只有java.lang包下的内容不需要导包，其他都需要</p><p>引用类型的一般使用步骤：1.导包：地址.类名2.创建：类名称 对象名 &#x3D; new 类名称();3.使用：对象名.成员方法名</p><p><img src="/img/cr/Java-SE/23.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> sc.nextInt();<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.next();<br></code></pre></td></tr></table></figure><p>匿名对象：只使用唯一的一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>().name = <span class="hljs-string">&quot;111&quot;</span>;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>().showName();<br></code></pre></td></tr></table></figure><p>Random:.nextint()<strong>整个int范围</strong>；nextint(111)<strong>0(包括)到111(不包括)随机生成int数字</strong></p><p>数组长度不可改变，Arraylist长度可以改变</p><p>ArrayList<E>： <strong><E>代表泛型，且只能是引用类型，不能是基本类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>对于ArrayList，直接打印得到的不是地址，而是内容。如果内容为空，得到的是空的中括号：[]</p><p>list.add(111)添加元素；list.get(111)查看元素；list.remove移除元素；list.size()获取长度</p><p>想要存储基本类型就要使用包装类，包装类名称为首字母大写(如byte-&gt;Byte,特殊：int-&gt;Integer;char-&gt;Character)</p></blockquote><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><blockquote><p>字符串是常量，他们的值在创建后不能更改，所以字符串可以共享使用</p><p>字符串效果上是char[]字符数组，但是底层原理是一个byte[]字节数组</p><p><img src="/img/cr/Java-SE/24.png"></p><p>注意：直接写上双引号，就是字符串对象（jvm帮忙new了）</p><p>字符串常量池：程序中只有直接写上双引号的字符串，才放在字符串常量池中</p><p>对于基本类型：&#x3D;&#x3D;进行数值的比较</p><p>对于引用类型：&#x3D;&#x3D;进行地址值的比较</p><p><img src="/img/cr/Java-SE/25.png"></p><p>要进行字符串内容的比较，使用函数：equals(Object obj)参数可以是任何对象，但只有参数是一个字符串且内容相同时才会给false。</p><p>str1.equals(str2)：str1不能为null值，会造成空指针异常；str2可以，只会warning不会报错。因此str1最好为常量，str2为变量</p><p>equalsIgnoreCase(String str)忽略大小写，进行内容比较</p><p><img src="/img/cr/Java-SE/26.png"></p><p><strong>substring</strong>: substring(int index);  substring(int begin,int end)(<strong>(begin,end]</strong>)</p><p>数字符索引值，从0开始，一个右箭头加一，切割想要的单词时，按住shift键右箭头继续加一</p><p><img src="/img/cr/Java-SE/27.png"></p><p>切割字符串：split(String regex)  切割为一个字符串数组</p><p>如果以”.”切割，必须以”\.”切割，否则切割不成功</p></blockquote><h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><blockquote><p>使用static关键字，内容属于类，凡本类对象都共享一份</p><p>修饰成员变量如共同教室，idCoounter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">idCounter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-number">111</span>)</span> &#123;<br>       <span class="hljs-number">111</span><br>       id = ++idCounter;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>       id = ++idCounter;<br>   &#125;<br></code></pre></td></tr></table></figure><p>普通方法可以用<em>对象名.方法名</em>使用，静态方法还可以使用<em>类名.静态方法名</em>使用(推荐)</p><p><img src="/img/cr/Java-SE/28.png"></p><p><img src="/img/cr/Java-SE/29.png"></p><p>静态代码块：(静态内容总是优先于非静态内容)(第一次使用本类时执行唯一的一次)</p><p>常用用图：一次性地对静态成员变量进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名称&#123;<br><span class="hljs-keyword">static</span>&#123;<br><span class="hljs-number">111</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记1</title>
    <link href="/2025/07/27/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2025/07/27/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h5 id="十进制和二进制之间的转换"><a href="#十进制和二进制之间的转换" class="headerlink" title="十进制和二进制之间的转换"></a>十进制和二进制之间的转换</h5><blockquote><p><img src="/img/cr/Java-SE/Java-SE/2.png"></p><p>HEX-&gt;十六进制；DEC-&gt;十进制；OCT-&gt;八进制；BIN-&gt;二进制</p></blockquote><h5 id="计算机存储单位："><a href="#计算机存储单位：" class="headerlink" title="计算机存储单位："></a>计算机存储单位：</h5><blockquote><p><img src="/img/cr/Java-SE/4.png"></p><p><img src="/img/cr/Java-SE/1.png"></p></blockquote><h5 id="JDK、JRE和JVM之间的关系"><a href="#JDK、JRE和JVM之间的关系" class="headerlink" title="JDK、JRE和JVM之间的关系:"></a>JDK、JRE和JVM之间的关系:</h5><blockquote><p><img src="/img/cr/Java-SE/3.png"></p></blockquote><h5 id="HelloWord代码的编译运行："><a href="#HelloWord代码的编译运行：" class="headerlink" title="HelloWord代码的编译运行："></a>HelloWord代码的编译运行：</h5><blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">javac HelloWorld.java<br>java HelloWorld<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Hello World!!!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="关键字、标识符和常量："><a href="#关键字、标识符和常量：" class="headerlink" title="关键字、标识符和常量："></a>关键字、标识符和常量：</h5><blockquote><p><img src="/img/cr/Java-SE/8.png"></p><p><img src="/img/cr/Java-SE/9.png"></p><ul><li><p>两个单引号之间不能什么都没有，也不能有两个及以上个字符</p></li><li><p>空常量不能直接打印输出</p></li></ul></blockquote><h5 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h5><blockquote><p><img src="/img/cr/Java-SE/10.png"></p><p><img src="/img/cr/Java-SE/11.png"></p></blockquote><p><img src="/img/cr/Java-SE/12.png"></p><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><blockquote><p>自动和强制，自动类型转换必须是范围小的转换成范围大的</p><p>强制类型转换一般不推荐使用，可能会发生精度损失和数据溢出</p><p>byte&#x2F;short&#x2F;char在进行运算时，先变成int类型，再进行运算</p><p>boolean类型不能发送数据类型转换</p></blockquote><h5 id="ascii码"><a href="#ascii码" class="headerlink" title="ascii码"></a>ascii码</h5><blockquote><p>48-&gt;0;65-&gt;A;97-&gt;a</p><p><img src="/img/cr/Java-SE/13.png"></p></blockquote><h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><blockquote><p>运算时类型不统一时，结果会是数据类型范围大的那一个（字符串和任何数据类型连接都会变成字符串）</p><p>对于字符串，+号相当于拼接符</p><p>只有变量才能自增自减和赋值，常量不行</p><p>三元运算翻译必须两个表达式都符合左侧数据类型的要求</p><p>三元运算符的结果必须被使用</p><p>对于byte&#x2F;short&#x2F;char类型，如果右侧赋值的数值没有超过范围，javac编译器自动强制转换（byte）&#x2F;（short）&#x2F;（char）</p><p>赋值时右侧表达式全是常量，javac编译器直接得到结果，存储结果而非表达式</p></blockquote><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><blockquote><p><img src="/img/cr/Java-SE/14.png"></p><p>do while循环的while后的分号不能忘记</p><p>死循环标准格式：while(true){}</p></blockquote><h5 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h5><blockquote><p><img src="/img/cr/Java-SE/15.png"></p><p>shift+f6  相同内容同时修改</p><p>psvm、5.fori、array.fori</p></blockquote><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>方法重载：方法名称一样，参数列表不一样（个数、类型、多类型顺序）（与方法返回值类型和参数名称无关）</p></blockquote><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><blockquote><h5 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h5><blockquote><p>类型统一且长度不可变</p><p>动态初始化数组（创建数组时直接指定数据个数多少）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arrayA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">300</span>];<br></code></pre></td></tr></table></figure><p>静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arrayB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;sddf&quot;</span>, <span class="hljs-string">&quot;gdd&quot;</span>&#125;;<br><span class="hljs-type">int</span>[] arrayC = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p>动态初始化数组可以拆分成两步，而动态初始化不行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arrayA;<br>arrayA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">300</span>];<br></code></pre></td></tr></table></figure><p>直接打印数组，得到的是数组对应的内存地址哈希值</p><p><img src="/img/cr/Java-SE/16.png"></p></blockquote><h5 id="数组的内存"><a href="#数组的内存" class="headerlink" title="数组的内存"></a>数组的内存</h5><blockquote><p><img src="/img/cr/Java-SE/17.png"></p><p><img src="/img/cr/Java-SE/18.png"></p><p><img src="/img/cr/Java-SE/19.png"></p><p>所以叫引用类型</p></blockquote><h5 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h5><blockquote><p>如果访问数组元素的时候，索引编号并不存在，那么将会发生</p><p>数组索引越界异常</p><p>ArrayIndexOutOfBoundsException</p><p>数组没有进行new初始化，就会发生</p><p>空指针异常</p><p>NullPointerException</p></blockquote><h5 id="数组函数使用"><a href="#数组函数使用" class="headerlink" title="数组函数使用"></a>数组函数使用</h5><blockquote><p>获取数组的长度：array.length</p><p>遍历输出数组所有的值</p><p>Arrays.toString(111)数组转换为字符串</p></blockquote></blockquote><h5 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h5><blockquote><p>成员变量直接定义在类中，方法外面</p><p>成员方法不要写static关键字</p><p>类名称 对象名 &#x3D; new 类名称（）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/20.png"></p><p>注意：方法并不是直接存放在堆里面，堆里面存放的只是堆在方法区的内存地址</p><p>当一个对象作为参数，传递到方法中时，实际上传递进去的是对象的地址值</p><p>对象作为返回值时，返回的值也是对象的地址值</p><p><img src="/img/cr/Java-SE/21.png"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客日常更新指令</title>
    <link href="/2025/07/15/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%B8%B8%E6%9B%B4%E6%96%B0%E6%8C%87%E4%BB%A4/"/>
    <url>/2025/07/15/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%B8%B8%E6%9B%B4%E6%96%B0%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>指令集合：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo cl<span class="hljs-variable">&amp;&amp;hexo</span> g<span class="hljs-variable">&amp;&amp;hexo</span> s<br>(清除缓存+生成更改+测试网页)<br>hexo d<br>(推送到服务器)<br>git <span class="hljs-keyword">add</span> .<br>git commit -m <span class="hljs-string">&quot;更新描述&quot;</span><br>git push origin master<br></code></pre></td></tr></table></figure><p>记得ctrl+f5强制刷新</p><p>参数运用：</p><p><img src="/img/cr/1.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
